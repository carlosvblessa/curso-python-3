Aula 1

Abordamos a criação da classe ItemCardapio como base para a criação de itens de cardápio em um sistema de restaurante. Os instrutores explicam a importância de organizar o código em pastas e arquivos separados, e demonstram como criar uma classe base com os atributos comuns a todos os itens do cardápio, como nome e preço.Além disso, são apresentadas as classes Prato e Bebida, que herdarão da classe ItemCardapio. A aula destaca a importância do uso do paradigma de orientação a objetos para organizar e estruturar o código de forma eficiente, e introduz o conceito de "classe mãe" para definir o comportamento e os atributos que serão compartilhados por outras classes.

Aprendemos sobre o conceito de herança na programação orientada a objetos.Em resumo, a herança permite que uma classe (subclasse) herde atributos e comportamentos de outra classe (classe base, mãe ou pai). Isso promove a reutilização de código e a criação de um padrão para as classes.Na aula, foi demonstrado como as classes Prato e Bebida herdam da classe ItemCardapio, aproveitando os atributos nome e preco, e adicionando seus próprios atributos específicos, como descricao e tamanho, respectivamente.

Aprendemos como instanciar as classes Bebida e Prato criadas anteriormente, para verificar se tudo está funcionando corretamente. Eles mostram como importar as classes para o arquivo app.py, criar objetos de cada classe com seus respectivos atributos (nome, preço, tamanho para Bebida e nome, preço, descrição para Prato) e, em seguida, como imprimir esses objetos no console.Além disso, eles explicam como personalizar a representação textual dos objetos das classes Bebida e Prato utilizando o método __str__, para que ao imprimir um objeto, seja exibido o nome do item em vez de um endereço de memória.O objetivo final da aula é preparar o terreno para adicionar os itens do cardápio (bebida e prato) ao restaurante "Praça", o que será abordado em aulas futuras.

Aqui está um resumo dos tópicos ensinados nesta aula:
Criamos a classe principal chamada ItemCardapio com um construtor que aceita os parâmetros nome e preço;

Implementamos duas classes chamadas Bebida e Prato que herdam atributos e métodos da classe ItemCardapio, utilizando super() no construtor para aproveitar a estrutura da classe pai;

Criamos objetos das classes Prato e Bebida, demonstrando como a herança pode ser utilizada para compartilhar funcionalidades entre diferentes tipos de itens de cardápio.

Aula 2

Aprendemos como integrar um cardápio aos restaurantes, permitindo adicionar bebidas e pratos a ele. Eles criam uma lista vazia chamada _cardapio na classe Restaurante para armazenar os itens do cardápio.Em seguida, são definidos dois métodos: adicionar_bebida_no_cardapio() e adicionar_prato_no_cardapio(), que recebem como parâmetro a bebida ou o prato a ser adicionado e utilizam o método append() para incluí-los na lista _cardapio.Por fim, eles mostram como utilizar esses métodos no arquivo app.py para adicionar uma bebida (suco) e um prato (pãozinho) ao cardápio do restaurante_praca.

Refatoramos o código para evitar a repetição ao adicionar itens ao cardápio do restaurante. Anteriormente, havia métodos separados para adicionar bebidas e pratos, o que se tornava ineficiente à medida que o cardápio crescia.Para resolver isso, eles criam um método genérico chamado adicionar_no_cardapio(), que recebe um item como parâmetro e utiliza a função isinstance() para verificar se o item é uma instância da classe itemCardapio (ou de uma classe derivada dela). Se for, o item é adicionado ao cardápio.Essa abordagem permite adicionar qualquer tipo de item (bebida, prato, sobremesa, etc.) ao cardápio utilizando um único método, simplificando o código e tornando-o mais fácil de manter.

Vimos o conceito de classe abstrata e como utilizá-la para garantir que todas as classes derivadas de ItemCardapio implementem o método aplicar_desconto.A classe abstrata serve como um modelo, definindo que um método deve existir nas classes filhas, mas sem especificar como ele deve ser implementado. Isso é feito utilizando o decorator @abstractmethod.A instrutora Laís complementa, explicando que ao importar ABC e herdar de ItemCardapio(ABC), estamos essencialmente dizendo que ItemCardapio é uma classe abstrata.O instrutor Guilherme demonstra que, ao tentar instanciar as classes Bebida e Prato sem implementar o método aplicar_desconto, o programa retorna um erro, reforçando a obrigatoriedade da implementação do método abstrato nas classes derivadas.


Aprendemos sobre a implementação de descontos em classes de diferentes tipos de itens de um cardápio (pratos e bebidas) utilizando o conceito de polimorfismo.Foi demonstrado como aplicar descontos específicos para cada tipo de item (8% para bebidas e 5% para pratos), sobrescrevendo o método aplicar_desconto() em cada classe (Bebida e Prato).Além disso, foi explicado como o Python permite que o mesmo método tenha implementações diferentes em classes distintas, adaptando-se às necessidades de cada uma. Também foi abordada a possibilidade de não aplicar desconto algum, utilizando a declaração pass no método, mostrando a flexibilidade do polimorfismo.Em resumo, o polimorfismo permite que um método se adapte e se comporte de maneira diferente em cada classe, garantindo a aplicação correta das regras de negócio para cada tipo de item do cardápio.

Nesta aula:
Criamos um método para adicionar itens ao cardápio e refatoramos a função para receber qualquer objeto que seja uma instância de ItemCardapio;

Utilizamos o conceito de property para exibir o cardápio de cada restaurante, proporcionando uma visão clara dos itens disponíveis;

Desenvolvemos o método abstrato chamado aplicar_desconto que permite aplicar descontos de forma flexível a diferentes tipos de itens no cardápio;

Aplicamos um valor de desconto tanto em bebidas quanto em pratos, destacando o polimorfismo na prática, onde diferentes classes respondem ao mesmo método de maneiras distintas.

Aula 3

Aprendemos sobre a importância de ambientes virtuais em Python para isolar as dependências de um projeto, garantindo que todos na equipe usem as mesmas versões do Python, bibliotecas e módulos.Você vai aprender a criar e ativar esses ambientes, além de entender as boas práticas para configurá-los corretamente.Em resumo, ambientes virtuais são como "mini computadores" dentro do seu computador, permitindo que você trabalhe com diferentes versões de pacotes e frameworks (como Flask e Django) sem conflitos. Isso é essencial para o desenvolvimento back-end e facilita a colaboração em equipe, além de permitir testar projetos em diferentes versões de dependências.

Aprendemos o que é e como utilizar o venv, o ambiente virtual padrão do Python. Eles demonstram como criar um ambiente virtual utilizando o comando python -m venv venv, exploram as pastas "Include", "Lib" e "Scripts" criadas dentro do ambiente, e explicam o arquivo de configuração pyvenv.cfg.Além disso, ensinam como ativar e desativar o ambiente virtual tanto no Windows (./venv/Scripts/activate e deactivate) quanto no Mac/Linux (source venv/bin/activate e deactivate), mostrando que o nome do ambiente virtual aparece no início do caminho do terminal quando ativado. O objetivo é preparar o ambiente para a instalação de módulos e dependências do projeto.

Aprendemos como criar e utilizar um ambiente virtual em Python para isolar as dependências de um projeto. Eles demonstram como instalar bibliotecas utilizando o pip, como o pacote requests, e como listar os pacotes instalados com o comando pip freeze.Além disso, explicam a importância de manter um arquivo requirements.txt para registrar as dependências do projeto e garantir que todos os pacotes necessários estejam na versão correta. Eles também mostram como o ambiente virtual isola as dependências do projeto, evitando conflitos com outras versões instaladas no sistema operacional.

Aula 4

Apresentamos como o Python pode ser utilizado no back-end para coletar e compartilhar informações, permitindo que equipes de front-end e mobile criem interfaces visuais e aplicativos.É introduzido o conceito de API (Interface de Programação de Aplicações) como uma forma de expor recursos de uma aplicação, como informações de restaurantes ou cardápios, utilizando o protocolo HTTP para a comunicação entre cliente e servidor.O processo envolve o cliente fazendo uma requisição ao servidor, que processa essa requisição e retorna uma resposta com os dados solicitados. Em vez de retornar a estrutura completa da página (HTML, CSS, etc.), o objetivo é expor os dados de forma que possam ser facilmente utilizados por diferentes plataformas.Para isso, será necessário utilizar uma ferramenta em Python capaz de criar um servidor que fique aguardando requisições e, ao receber uma requisição para um recurso específico, retorne as informações corretas. Nas próximas aulas, será explorada a ferramenta em Python que será utilizada para criar esse servidor.

Aprendemos como fazer requisições HTTP para obter dados de uma API externa em formato JSON e como incorporar esses dados em um projeto Python.Inicialmente, eles explicam o que é um arquivo JSON e como ele pode ser usado para armazenar dados estruturados. Em seguida, eles mostram como usar a biblioteca requests do Python para fazer uma requisição GET para uma URL que retorna um JSON de restaurantes.Eles também abordam a importância de verificar o código de status da resposta para garantir que a requisição foi bem-sucedida. Caso o status seja 200, eles extraem os dados JSON da resposta e os imprimem no console. Caso contrário, eles exibem uma mensagem de erro com o código de status correspondente.

Aprendemos a filtrar dados de um arquivo JSON contendo informações de diversos restaurantes, separando-os em um dicionário onde cada chave é o nome do restaurante e o valor é uma lista com os cardápios. Os principais pontos abordados foram:
Acessar dados de um arquivo JSON.
Criar um dicionário para armazenar os dados dos restaurantes.
Iterar sobre os itens do JSON para extrair o nome do restaurante, prato, preço e descrição.
Verificar se o restaurante já existe no dicionário.
Criar uma lista vazia para o restaurante caso ele não exista no dicionário.
Adicionar os dados do cardápio (prato, preço e descrição) em um dicionário e adicionar esse dicionário à lista do restaurante correspondente.
Imprimir os dados de um restaurante específico para verificar o resultado.

Aprendemos como criar arquivos usando Python. O objetivo é pegar os dados do cardápio de diferentes restaurantes e criar um arquivo JSON para cada um deles, onde o nome do arquivo será o nome do restaurante.Para isso, utilizamos um laço for para iterar sobre os restaurantes e seus respectivos cardápios. Em seguida, criamos o nome do arquivo usando uma f-string e a extensão .json.Para criar o arquivo, utilizamos o comando with open, que permite manipular arquivos dentro da aplicação. Passamos o nome do arquivo e o modo de escrita ('w').Para escrever os dados no arquivo em formato JSON, importamos a biblioteca json e utilizamos a função json.dump(), passando os dados do cardápio, o arquivo e a identação para organizar o conteúdo.Ao executar o código, são criados os arquivos JSON com o cardápio de cada restaurante.

Nesta aula:
Exploramos o conceito de API (Interface de Programação de Aplicações) e compreendemos seu funcionamento como uma ponte entre diferentes sistemas, permitindo a comunicação e o compartilhamento de dados.

Utilizamos o módulo requests em Python para realizar requisições a APIs, aprendendo como obter dados de serviços externos e integrá-los em nossos programas.

Praticamos o processo de fazer requisições a uma API de restaurantes, utilizando o módulo requests para receber informações sobre cada estabelecimento em formato JSON.

Aprendemos a salvar os dados recebidos da API em arquivos JSON, permitindo-nos armazenar localmente as informações dos restaurantes para uso futuro.

Demonstramos como criar nossos próprios arquivos JSON, proporcionando uma compreensão prática de como estruturar e organizar dados em um formato legível e interoperável.

Aula 5

Nesta aula, você aprenderá a usar o FastAPI para criar uma API.Primeiro, você vai instalar o FastAPI e o Uvicorn. O FastAPI é um framework Python para construir APIs, e o Uvicorn é um servidor ASGI para executar a API.Em seguida, você vai criar um arquivo main.py e importar o FastAPI. Você vai criar um objeto FastAPI e usar o decorator @app.get() para criar um endpoint para a sua API. O endpoint /api/hello vai retornar a mensagem "Hello World".Por fim, você vai executar o servidor Uvicorn para rodar a API. Você poderá acessar a API no seu navegador através do endereço http://127.0.0.1:8000/api/hello.O desafio final é implementar a exibição das informações dos cardápios com base nos restaurantes.

Aprendemos como criar um novo endpoint em uma aplicação FastAPI para buscar o cardápio de restaurantes.
Criação do Endpoint:
Utilização de @app.get() para definir a rota /api/restaurantes/.
Criação da função get_restaurantes() para lidar com a lógica do endpoint.


Recebimento de Argumento:
Uso do módulo Query do FastAPI para receber o nome do restaurante como argumento na URL.
Definição do argumento restaurante: str = Query(None) na função get_restaurantes().


Implementação da Lógica:
Cópia do código da aula anterior para buscar os dados dos restaurantes a partir de uma URL.
Verificação se o argumento restaurante é None. Se for, retorna todos os dados dos restaurantes.
Se o argumento restaurante for especificado, filtra os dados para retornar apenas o cardápio do restaurante correspondente.


Retorno dos Dados:
Retorno dos dados no formato JSON, contendo o nome do restaurante e seu cardápio.
Tratamento de erros, retornando o código de status da resposta em caso de falha na requisição.

Nesta aula, aprendemos a testar nossa API FastAPI para verificar se tudo está funcionando corretamente.
Consultando endpoints:
Usamos o comando uvicorn main:app --reload para iniciar o servidor e acessamos os endpoints /api/hello e /api/restaurantes no navegador.
Testamos a busca de restaurantes específicos adicionando ?restaurante=NomeDoRestaurante ao endpoint /api/restaurantes.


Documentação Automática com /docs:
Acessamos a documentação da API através do endpoint /docs para visualizar todos os endpoints disponíveis.
Adicionamos docstrings às funções dos endpoints no arquivo main.py para fornecer descrições que aparecem na documentação.


Testando os endpoints na documentação:
Utilizamos a interface /docs para testar os endpoints diretamente no navegador, preenchendo os parâmetros necessários e executando as requisições.
Analisamos o corpo da resposta (Response body) e o código de status (status_code) para verificar se a API está funcionando como esperado.

Nesta aula:
Instalamos a biblioteca FastAPI e configuramos um ambiente para criar uma API utilizando Python;

Criamos um endpoint utilizando o FastAPI para disponibilizar recursos relacionados aos restaurantes, permitindo que usuários acessem informações específicas sobre esses estabelecimentos;

Adicionamos um endpoint que pode receber um parâmetro de consulta (query parameter) para filtrar restaurantes com base em seus nomes, proporcionando uma maneira flexível de buscar informações específicas;

Utilizamos as ferramentas de documentação docs e redoc do FastAPI para gerar automaticamente documentação interativa para a API, facilitando a compreensão dos endpoints disponíveis e permitindo testes diretos na interface de documentação.





